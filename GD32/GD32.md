# GD32F130C8T6 Complete Reference Guide

## Overview

The **GD32F130C8T6** is a 32-bit ARM Cortex-M3 microcontroller manufactured by GigaDevice as a pin-compatible clone of the STM32F103C8T6. It offers enhanced performance with higher clock speeds while maintaining software and hardware compatibility with STM32 development tools.

### Key Specifications
- **Architecture**: ARM Cortex-M3 r2p1
- **Flash Memory**: 64KB (0x08000000 - 0x0800FFFF)
- **SRAM**: 8KB (0x20000000 - 0x20001FFF) 
- **Max Clock Speed**: 108MHz (vs 72MHz for STM32F103C8T6)
- **Operating Voltage**: 2.6V - 3.6V
- **Package**: LQFP48
- **Device ID**: 0x13030410

### Key Differences from STM32F103C8T6
- **Reduced SRAM**: 8KB vs 20KB in STM32F103C8T6
- **Higher Clock**: Up to 108MHz vs 72MHz
- **Different Device ID**: 0x13030410 vs 0x410 for STM32
- **Same Flash Size**: 64KB
- **Pin Compatible**: Drop-in replacement for most applications

## Hardware Connections

### ST-LINK V2 to GD32F130C8T6 Wiring

| ST-LINK V2 Pin | Function | GD32F130C8T6 Pin | Description |
|----------------|----------|------------------|-------------|
| Pin 1 (VAPP)   | Target VCC Reference | VDD | **Critical for voltage detection** |
| Pin 2 (GND)    | Ground | GND | Common ground |
| Pin 3 (SWDIO)  | Serial Wire Data | PA13 | SWD data line |
| Pin 5 (SWCLK)  | Serial Wire Clock | PA14 | SWD clock line |
| Pin 8 (nRST)   | Reset (Optional) | NRST | Hardware reset |
| Pin 9 (3V3)    | Power Output | VDD | 3.3V power (if not externally powered) |

**⚠️ Critical Connection**: The VAPP pin (Pin 1) **MUST** be connected to the target's VDD for OpenOCD to read the correct voltage. Missing this connection will cause "target voltage too low" errors.

### Boot Pin Configuration
For normal SWD debugging and flashing:
- **BOOT0**: Low (0V) - Boot from flash
- **BOOT1**: Don't care (typically low)

## OpenOCD Configuration

### Custom GD32F1x0 Target Configuration

Create a custom target file: `gd32f1x.cfg`

```tcl
# script for GD32F1x0 family (e.g., GD32F130C8T6)
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]

if { [info exists CHIPNAME] } {
    set _CHIPNAME $CHIPNAME
} else {
    set _CHIPNAME gd32f1x
}

set _ENDIAN little

if { [info exists WORKAREASIZE] } {
    set _WORKAREASIZE $WORKAREASIZE
} else {
    set _WORKAREASIZE 0x2000
}

adapter speed 1000

adapter srst delay 100
if {[using_jtag]} {
    jtag_ntrst_delay 100
}

if { [info exists CPUTAPID] } {
    set _CPUTAPID $CPUTAPID
} else {
    if { [using_jtag] } {
        set _CPUTAPID 0x3ba00477
    } {
        set _CPUTAPID 0x13030410
    }
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
dap create $_CHIPNAME.dap -chain-position $_CHIPNAME.cpu

if {[using_jtag]} {
    jtag newtap $_CHIPNAME bs -irlen 5
}

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap

$_TARGETNAME configure -work-area-phys 0x20000000 -work-area-size $_WORKAREASIZE -work-area-backup 0

set _FLASHNAME $_CHIPNAME.flash
flash bank $_FLASHNAME stm32f1x 0x08000000 0x00010000 0 0 $_TARGETNAME

reset_config srst_nogate

if {![using_hla]} {
    cortex_m reset_config sysresetreq
}

proc gd32f1x_default_reset_start {} {
    adapter speed 1000
}

proc gd32f1x_default_examine_end {} {
    mmw 0xe0042004 0x00000007 0
}

proc gd32f1x_default_reset_init {} {
    mww 0x40021004 0x001c0000
    mmw 0x40021000 0x01000000 0
    mww 0x40022000 0x00000012
    sleep 10
    mmw 0x40021004 0x00000002 0
    adapter speed 8000
}

$_TARGETNAME configure -event examine-end { gd32f1x_default_examine_end }
$_TARGETNAME configure -event reset-start { gd32f1x_default_reset_start }
$_TARGETNAME configure -event reset-init { gd32f1x_default_reset_init }

$_TARGETNAME configure -event trace-config {
    mmw 0xe0042004 0x00000020 0
}
```

Save this as `C:\openocd\scripts\target\gd32f1x.cfg`

### OpenOCD Commands

#### Basic Connection Command
```bash
openocd -f interface/stlink.cfg -c "transport select hla_swd" -f target/gd32f1x.cfg
```

#### Alternative using STM32F1x config (may work but not optimal)
```bash
openocd -f interface/stlink.cfg -c "transport select hla_swd" -f target/stm32f1x.cfg
```

#### Connection with Speed Control
```bash
openocd -f interface/stlink.cfg -c "transport select hla_swd" -c "adapter speed 1000" -f target/gd32f1x.cfg
```

#### Expected Successful Output
```
Info : STLINK V2J46S7 (API v2) VID:PID 0483:3748
Info : Target voltage: 3.203670
Info : [gd32f1x.cpu] Cortex-M3 r1p1 processor detected
Info : [gd32f1x.cpu] target has 6 breakpoints, 4 watchpoints
Info : [gd32f1x.cpu] Examination succeed
Info : starting gdb server on 3333
Info : Listening on port 3333 for gdb connections
```

## Telnet Commands

Connect to OpenOCD via telnet for direct commands:
```bash
telnet localhost 4444
```

### Essential Telnet Commands

#### Halt and Probe Flash
```
halt
flash probe 0
flash banks
```

#### Read Option Bytes (Check Read Protection)
```
mdb 0x1FFFF800 16
```
Expected output for unprotected chip:
```
0x1ffff800: a5 5a ff 00 ff 00 ff 00 ff 00 ff 00 ff ff ff ff
```
- `a5` = RDP Level 0 (no read protection)
- Any other value indicates protection is enabled

#### Read Full Flash Memory (64KB)
```
flash read_bank 0 flash.bin 0 0x10000
```

#### Read Specific Memory Locations
```
mdw 0x08000000 100    # Read 100 words from flash start
mdb 0x20000000 256    # Read 256 bytes from SRAM start
```

#### Write Flash
```
flash write_bank 0 firmware.bin 0
```

#### Mass Erase
```
stm32f1x mass_erase 0
```

## Programming and Flashing

### Complete Flash Programming Sequence
```bash
# Start OpenOCD
openocd -f interface/stlink.cfg -c "transport select hla_swd" -f target/gd32f1x.cfg -c "program firmware.bin 0x08000000 verify reset exit"
```

### Step-by-Step Flashing via Telnet
```bash
# Connect to telnet
telnet localhost 4444

# Commands in telnet session:
halt
flash probe 0
flash erase_sector 0 0 last     # Erase all sectors
flash write_bank 0 firmware.bin 0
verify_image firmware.bin 0x08000000
reset run
```

## Troubleshooting Common Issues

### 1. "Target voltage may be too low for reliable debugging"

**Cause**: VAPP pin not connected to target VDD

**Solution**: 
- Connect ST-LINK Pin 1 (VAPP) to GD32 VDD
- Verify 3.3V power supply is stable
- Check all SWD connections

### 2. "init mode failed (unable to connect to the target)"

**Possible Causes & Solutions**:

**Device ID Mismatch**:
- Use custom `gd32f1x.cfg` with correct device ID (0x13030410)
- Or modify existing STM32F1x config to recognize GD32 device ID

**Hardware Issues**:
- Verify BOOT0 = 0 (boot from flash)
- Check SWD pin connections (PA13/SWDIO, PA14/SWCLK)
- Ensure stable 3.3V power supply
- Update ST-LINK firmware

**SRAM Size Mismatch**:
- GD32F130C8T6 has only 8KB SRAM vs 20KB in STM32F103C8T6
- Use custom config with `_WORKAREASIZE 0x2000`

### 3. Partial Code Extraction

If `flash read_bank` only extracts partial code:

**Verify Read Protection**:
```
mdb 0x1FFFF800 16
```
Look for `a5` (unprotected) or other values (protected)

**Check Flash Size**:
```bash
# Verify extracted file is exactly 65,536 bytes (64KB)
ls -l flash.bin
```

**Try Alternative Tools**:
- Use STM32CubeProgrammer instead of OpenOCD
- Select STM32F103C8T6 profile for compatibility

### 4. "current_target out of bounds" Error

**Cause**: Incorrect command order in OpenOCD

**Solution**: Use proper command sequence:
```bash
openocd -f interface/stlink.cfg -c "transport select hla_swd" -c "adapter speed 1000" -f target/gd32f1x.cfg
```
Don't use `init; reset init` before target configuration.

## Code Analysis with Ghidra

### Ghidra Configuration for GD32F130C8T6

1. **Import Settings**:
   - Language: ARM → Cortex → 32-bit → little-endian
   - Base Address: `0x08000000`
   - Processor: ARMv7-M (Cortex-M3)

2. **Memory Map Setup**:
   - Flash: `0x08000000` to `0x0800FFFF` (64KB)
   - SRAM: `0x20000000` to `0x20001FFF` (8KB)
   - Peripherals: `0x40000000` to `0xEFFFFFFF`

3. **Thumb Mode**:
   - Ensure TMode = 1 for proper Thumb-2 disassembly
   - Use `CTRL+R` to manually set if needed

### Disassembly with objdump
```bash
arm-none-eabi-objdump -D -b binary -m arm flash.bin > flash.dis
```

## ARM Toolchain Integration

### Required Tools
- **arm-none-eabi-gcc**: Compiler
- **arm-none-eabi-objdump**: Disassembler  
- **arm-none-eabi-objcopy**: Binary converter
- **arm-none-eabi-as**: Assembler
- **arm-none-eabi-ld**: Linker

### Installation (Windows)
1. Download: `arm-gnu-toolchain-14.2.rel1-mingw-w64-x86_64-arm-none-eabi.exe`
2. Install with PATH option: `installer.exe /P`
3. Verify: `arm-none-eabi-objdump --version`

### Adding to PATH (Manual)
```bash
# Add to system PATH:
C:\Program Files (x86)\Arm GNU Toolchain arm-none-eabi\14.2 rel1\bin
```

### Sample Compilation
```bash
# Compile for Cortex-M3
arm-none-eabi-gcc -mcpu=cortex-m3 -mthumb -T linker.ld -o program.elf program.c

# Convert to binary
arm-none-eabi-objcopy -O binary program.elf program.bin

# Disassemble
arm-none-eabi-objdump -D program.elf
```

### Linker Script for GD32F130C8T6
```ld
MEMORY
{
  FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 64K
  RAM (rwx) : ORIGIN = 0x20000000, LENGTH = 8K
}

SECTIONS
{
  .text :
  {
    *(.text)
    *(.rodata)
  } > FLASH
  
  .data :
  {
    *(.data)
  } > RAM AT > FLASH
  
  .bss :
  {
    *(.bss)
  } > RAM
}
```

## Raspberry Pi Interface

### Hardware Connections

#### SWD Interface (Raspberry Pi → GD32F130C8T6)
| Raspberry Pi GPIO | Function | GD32F130C8T6 Pin |
|-------------------|----------|------------------|
| GPIO 25 | SWCLK | PA14 |
| GPIO 24 | SWDIO | PA13 |
| GPIO 18 | nRST (optional) | NRST |
| 3.3V | Power | VDD |
| GND | Ground | GND |

#### Enable SPI (for bit-banging SWD)
```bash
sudo raspi-config
# Interface Options → SPI → Enable
```

### OpenOCD on Raspberry Pi

#### Installation
```bash
# Install OpenOCD
sudo apt update
sudo apt install openocd

# Install ARM toolchain
sudo apt install gcc-arm-none-eabi binutils-arm-none-eabi
```

#### GPIO-based SWD Interface Configuration

Create `bcm2835gpio.cfg`:
```tcl
# BCM2835 GPIO interface for SWD
interface bcm2835gpio

# SWD configuration
bcm2835gpio_swd_nums 24 25
# SWDIO = GPIO24, SWCLK = GPIO25

# Optional reset
# bcm2835gpio_srst_num 18

# Set speed (lower for stability)
adapter speed 100

transport select swd
```

#### OpenOCD Command for Raspberry Pi
```bash
sudo openocd -f bcm2835gpio.cfg -f target/gd32f1x.cfg
```

### Python Programming Interface

#### Using pyOCD
```bash
pip3 install pyocd
```

```python
#!/usr/bin/env python3
from pyocd.core.helpers import ConnectHelper
from pyocd.flash.file_programmer import FileProgrammer

# Connect to GD32F130C8T6
with ConnectHelper.session_with_chosen_probe() as session:
    board = session.board
    target = board.target
    flash = board.target.memory_map.get_boot_memory()
    
    # Read flash
    data = target.read_memory_block8(0x08000000, 65536)
    
    # Write to file
    with open('flash_dump.bin', 'wb') as f:
        f.write(bytearray(data))
    
    # Program flash
    FileProgrammer(session).program('firmware.bin')
```

#### GPIO Control (Python)
```python
#!/usr/bin/env python3
import RPi.GPIO as GPIO
import time

# SWD pin definitions
SWCLK = 25
SWDIO = 24
nRST = 18

GPIO.setmode(GPIO.BCM)
GPIO.setup(SWCLK, GPIO.OUT)
GPIO.setup(SWDIO, GPIO.OUT)
GPIO.setup(nRST, GPIO.OUT)

def swd_reset():
    """Reset target via SWD"""
    # Pull reset low
    GPIO.output(nRST, GPIO.LOW)
    time.sleep(0.1)
    
    # Release reset
    GPIO.output(nRST, GPIO.HIGH)
    time.sleep(0.1)

def swd_init():
    """Initialize SWD interface"""
    # Send reset sequence
    GPIO.output(SWDIO, GPIO.HIGH)
    for i in range(50):
        GPIO.output(SWCLK, GPIO.HIGH)
        time.sleep(0.001)
        GPIO.output(SWCLK, GPIO.LOW)
        time.sleep(0.001)
    
    # Send JTAG-to-SWD sequence
    sequence = [0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1]
    for bit in sequence:
        GPIO.output(SWDIO, bit)
        GPIO.output(SWCLK, GPIO.HIGH)
        time.sleep(0.001)
        GPIO.output(SWCLK, GPIO.LOW)
        time.sleep(0.001)

# Cleanup
def cleanup():
    GPIO.cleanup()
```

### SWD Protocol Implementation

#### Basic SWD Functions (Raspberry Pi)
```python
def swd_write_reg(reg_addr, data):
    """Write to SWD register"""
    # Implementation depends on SWD protocol
    # This is a simplified example
    pass

def swd_read_reg(reg_addr):
    """Read from SWD register"""
    # Implementation depends on SWD protocol
    return 0

def swd_read_memory(address, count):
    """Read memory via SWD"""
    data = []
    for i in range(count):
        # Use MEMORY_AP to read memory
        value = swd_read_reg(0x00)  # Simplified
        data.append(value)
    return data
```

## STM32CubeProgrammer Alternative

### Installation and Usage
```bash
# Download STM32CubeProgrammer from ST website
# Connect via ST-LINK
STM32_Programmer_CLI -c port=SWD

# Select compatible chip (use STM32F103C8 for GD32F130C8T6)
STM32_Programmer_CLI -c port=SWD -d firmware.bin 0x08000000

# Read flash
STM32_Programmer_CLI -c port=SWD -r 0x08000000 0x10000 flash_dump.bin
```

## Memory Map Reference

### GD32F130C8T6 Memory Layout
```
0x08000000 - 0x0800FFFF : Flash Memory (64KB)
0x20000000 - 0x20001FFF : SRAM (8KB)
0x1FFFF800 - 0x1FFFF80F : Option Bytes
0x1FFFF000 - 0x1FFFF7FF : System Memory (Bootloader)
0x40000000 - 0x4001FFFF : APB1 Peripherals
0x40020000 - 0x4002FFFF : APB2 Peripherals  
0x40030000 - 0x5003FFFF : AHB Peripherals
0xE0000000 - 0xE00FFFFF : Cortex-M3 Internal Peripherals
```

### Common Peripheral Base Addresses
```
RCC     : 0x40021000
GPIOA   : 0x40010800
GPIOB   : 0x40010C00
GPIOC   : 0x40011000
USART1  : 0x40013800
USART2  : 0x40004400
TIM1    : 0x40012C00
TIM2    : 0x40000000
TIM3    : 0x40000400
ADC1    : 0x40012400
```

## Development Tips

### 1. Verification Steps
Always verify extracted firmware:
```bash
# Check file size (should be 65,536 bytes)
ls -l flash.bin

# Verify checksum matches original
md5sum flash.bin

# Quick content check
hexdump -C flash.bin | head -n 20
```

### 2. Backup Before Modifications
```bash
# Always backup original firmware
cp flash.bin flash_original_backup.bin

# Document device information
echo "Device: GD32F130C8T6" > device_info.txt
echo "Date: $(date)" >> device_info.txt
echo "Size: $(wc -c < flash.bin) bytes" >> device_info.txt
```

### 3. Clone Chip Programming
When programming identical GD32F130C8T6 chips:
```bash
# Extract from source chip
openocd -f interface/stlink.cfg -c "transport select hla_swd" -f target/gd32f1x.cfg -c "init; halt; flash read_bank 0 source.bin 0 0x10000; reset; exit"

# Program to target chip
openocd -f interface/stlink.cfg -c "transport select hla_swd" -f target/gd32f1x.cfg -c "program source.bin 0x08000000 verify reset exit"
```

## References and Resources

### Official Documentation
- [GigaDevice Official Website](https://www.gigadevice.com/)
- [GD32F1x0 Series Datasheet](https://www.gigadevice.com/datasheet/)
- [GD32F1x0 User Manual](https://www.gigadevice.com/manual/)

### Community Resources
- [OpenOCD Manual](http://openocd.org/doc/html/index.html)
- [ARM Developer Documentation](https://developer.arm.com/)
- [EEVBlog Forum - GD32 Discussions](https://www.eevblog.com/forum/)

### Tools
- [Ghidra Reverse Engineering](https://ghidra-sre.org/)
- [STM32CubeProgrammer](https://www.st.com/en/development-tools/stm32cubeprog.html)
- [GNU Arm Embedded Toolchain](https://developer.arm.com/downloads/-/gnu-rm)

---

## Revision History
- v1.0: Initial comprehensive guide
- Based on practical troubleshooting and testing with GD32F130C8T6 chips
- Includes Windows and Raspberry Pi integration examples